# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Comments {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type CommentsAggregateGroupBy {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type CommentsConnection {
  """Array of edges."""
  edges: [CommentsEdge!]!

  """Paging information"""
  pageInfo: PageInfo!
}

type CommentsCountAggregate {
  createdAt: Int
  deletedAt: Int
  id: Int
  updatedAt: Int
}

input CommentsCreatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

input CommentsDeleteFilter {
  and: [CommentsDeleteFilter!]
  createdAt: CommentsCreatedAtFilterComparison
  deletedAt: CommentsDeletedAtFilterComparison
  id: CommentsIdFilterComparison
  or: [CommentsDeleteFilter!]
  updatedAt: CommentsUpdatedAtFilterComparison
}

type CommentsDeleteResponse {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input CommentsDeletedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

type CommentsEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the Comments"""
  node: Comments!
}

input CommentsFilter {
  and: [CommentsFilter!]
  createdAt: CommentsCreatedAtFilterComparison
  deletedAt: CommentsDeletedAtFilterComparison
  id: CommentsIdFilterComparison
  or: [CommentsFilter!]
  updatedAt: CommentsUpdatedAtFilterComparison
}

input CommentsIdFilterComparison {
  eq: String
  in: [String!]
  neq: String
  notIn: [String!]
}

type CommentsMaxAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type CommentsMinAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input CommentsSort {
  direction: SortDirection!
  field: CommentsSortFields!
  nulls: SortNulls
}

enum CommentsSortFields {
  createdAt
  deletedAt
  id
  updatedAt
}

input CommentsUpdateFilter {
  and: [CommentsUpdateFilter!]
  createdAt: CommentsCreatedAtFilterComparison
  deletedAt: CommentsDeletedAtFilterComparison
  id: CommentsIdFilterComparison
  or: [CommentsUpdateFilter!]
  updatedAt: CommentsUpdatedAtFilterComparison
}

input CommentsUpdatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

type Complaint {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type ComplaintAggregateGroupBy {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type ComplaintConnection {
  """Array of edges."""
  edges: [ComplaintEdge!]!

  """Paging information"""
  pageInfo: PageInfo!
}

type ComplaintCountAggregate {
  createdAt: Int
  deletedAt: Int
  id: Int
  updatedAt: Int
}

input ComplaintCreatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

input ComplaintDeleteFilter {
  and: [ComplaintDeleteFilter!]
  createdAt: ComplaintCreatedAtFilterComparison
  deletedAt: ComplaintDeletedAtFilterComparison
  id: ComplaintIdFilterComparison
  or: [ComplaintDeleteFilter!]
  updatedAt: ComplaintUpdatedAtFilterComparison
}

type ComplaintDeleteResponse {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input ComplaintDeletedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

type ComplaintEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the Complaint"""
  node: Complaint!
}

input ComplaintFilter {
  and: [ComplaintFilter!]
  createdAt: ComplaintCreatedAtFilterComparison
  deletedAt: ComplaintDeletedAtFilterComparison
  id: ComplaintIdFilterComparison
  or: [ComplaintFilter!]
  updatedAt: ComplaintUpdatedAtFilterComparison
}

input ComplaintIdFilterComparison {
  eq: String
  in: [String!]
  neq: String
  notIn: [String!]
}

type ComplaintMaxAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type ComplaintMinAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input ComplaintSort {
  direction: SortDirection!
  field: ComplaintSortFields!
  nulls: SortNulls
}

enum ComplaintSortFields {
  createdAt
  deletedAt
  id
  updatedAt
}

input ComplaintUpdateFilter {
  and: [ComplaintUpdateFilter!]
  createdAt: ComplaintCreatedAtFilterComparison
  deletedAt: ComplaintDeletedAtFilterComparison
  id: ComplaintIdFilterComparison
  or: [ComplaintUpdateFilter!]
  updatedAt: ComplaintUpdatedAtFilterComparison
}

input ComplaintUpdatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

input CreateCommentInput {
  commentBody: String!
  postId: Float!
  userId: String!
}

input CreateComplaintInput {
  comentId: String!
  type: Float!
  userId: String!
}

input CreateLikeInput {
  comentId: String!
  type: Float!
  userId: String!
}

input CreateManyCommentsInput {
  """Array of records to create"""
  comments: [CreateCommentInput!]!
}

input CreateManyComplaintsInput {
  """Array of records to create"""
  complaints: [CreateComplaintInput!]!
}

input CreateManyLikesInput {
  """Array of records to create"""
  likes: [CreateLikeInput!]!
}

input CreateManyPostsInput {
  """Array of records to create"""
  posts: [CreatePostInput!]!
}

input CreateManySessionsInput {
  """Array of records to create"""
  sessions: [CreateSessionInput!]!
}

input CreateManyUsersInput {
  """Array of records to create"""
  users: [CreateUserInput!]!
}

input CreateOneCommentsInput {
  """The record to create"""
  comments: CreateCommentInput!
}

input CreateOneComplaintInput {
  """The record to create"""
  complaint: CreateComplaintInput!
}

input CreateOneLikeInput {
  """The record to create"""
  like: CreateLikeInput!
}

input CreateOnePostInput {
  """The record to create"""
  post: CreatePostInput!
}

input CreateOneSessionInput {
  """The record to create"""
  session: CreateSessionInput!
}

input CreateOneUserInput {
  """The record to create"""
  user: CreateUserInput!
}

input CreatePostInput {
  category: String!
  postBody: String!
  postDateTime: DateTime!
  postImageURL: String!
  postStatus: Float!
  postTitle: String!
  postVisibility: Float!
  tags: String!
}

input CreateSessionInput {
  token: String!
}

input CreateUserInput {
  userEmail: String!
  userName: String!
  userPassword: String!
}

input CursorPaging {
  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DeleteManyCommentsInput {
  """Filter to find records to delete"""
  filter: CommentsDeleteFilter!
}

input DeleteManyComplaintsInput {
  """Filter to find records to delete"""
  filter: ComplaintDeleteFilter!
}

input DeleteManyLikesInput {
  """Filter to find records to delete"""
  filter: LikeDeleteFilter!
}

input DeleteManyPostsInput {
  """Filter to find records to delete"""
  filter: PostDeleteFilter!
}

type DeleteManyResponse {
  """The number of records deleted."""
  deletedCount: Int!
}

input DeleteManySessionsInput {
  """Filter to find records to delete"""
  filter: SessionDeleteFilter!
}

input DeleteManyUsersInput {
  """Filter to find records to delete"""
  filter: UserDeleteFilter!
}

input DeleteOneCommentsInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneComplaintInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneLikeInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOnePostInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneSessionInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneUserInput {
  """The id of the record to delete."""
  id: ID!
}

type Like {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type LikeAggregateGroupBy {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type LikeConnection {
  """Array of edges."""
  edges: [LikeEdge!]!

  """Paging information"""
  pageInfo: PageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type LikeCountAggregate {
  createdAt: Int
  deletedAt: Int
  id: Int
  updatedAt: Int
}

input LikeCreatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

input LikeDeleteFilter {
  and: [LikeDeleteFilter!]
  createdAt: LikeCreatedAtFilterComparison
  deletedAt: LikeDeletedAtFilterComparison
  id: LikeIdFilterComparison
  or: [LikeDeleteFilter!]
  updatedAt: LikeUpdatedAtFilterComparison
}

type LikeDeleteResponse {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input LikeDeletedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

type LikeEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the Like"""
  node: Like!
}

input LikeFilter {
  and: [LikeFilter!]
  createdAt: LikeCreatedAtFilterComparison
  deletedAt: LikeDeletedAtFilterComparison
  id: LikeIdFilterComparison
  or: [LikeFilter!]
  updatedAt: LikeUpdatedAtFilterComparison
}

input LikeIdFilterComparison {
  eq: String
  in: [String!]
  neq: String
  notIn: [String!]
}

type LikeMaxAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type LikeMinAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input LikeSort {
  direction: SortDirection!
  field: LikeSortFields!
  nulls: SortNulls
}

enum LikeSortFields {
  createdAt
  deletedAt
  id
  updatedAt
}

input LikeUpdateFilter {
  and: [LikeUpdateFilter!]
  createdAt: LikeCreatedAtFilterComparison
  deletedAt: LikeDeletedAtFilterComparison
  id: LikeIdFilterComparison
  or: [LikeUpdateFilter!]
  updatedAt: LikeUpdatedAtFilterComparison
}

input LikeUpdatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

type Mutation {
  createManyComments(input: CreateManyCommentsInput!): [Comments!]!
  createManyComplaints(input: CreateManyComplaintsInput!): [Complaint!]!
  createManyLikes(input: CreateManyLikesInput!): [Like!]!
  createManyPosts(input: CreateManyPostsInput!): [Post!]!
  createManySessions(input: CreateManySessionsInput!): [Session!]!
  createManyUsers(input: CreateManyUsersInput!): [User!]!
  createOneComments(input: CreateOneCommentsInput!): Comments!
  createOneComplaint(input: CreateOneComplaintInput!): Complaint!
  createOneLike(input: CreateOneLikeInput!): Like!
  createOnePost(input: CreateOnePostInput!): Post!
  createOneSession(input: CreateOneSessionInput!): Session!
  createOneUser(input: CreateOneUserInput!): User!
  deleteManyComments(input: DeleteManyCommentsInput!): DeleteManyResponse!
  deleteManyComplaints(input: DeleteManyComplaintsInput!): DeleteManyResponse!
  deleteManyLikes(input: DeleteManyLikesInput!): DeleteManyResponse!
  deleteManyPosts(input: DeleteManyPostsInput!): DeleteManyResponse!
  deleteManySessions(input: DeleteManySessionsInput!): DeleteManyResponse!
  deleteManyUsers(input: DeleteManyUsersInput!): DeleteManyResponse!
  deleteOneComments(input: DeleteOneCommentsInput!): CommentsDeleteResponse!
  deleteOneComplaint(input: DeleteOneComplaintInput!): ComplaintDeleteResponse!
  deleteOneLike(input: DeleteOneLikeInput!): LikeDeleteResponse!
  deleteOnePost(input: DeleteOnePostInput!): PostDeleteResponse!
  deleteOneSession(input: DeleteOneSessionInput!): SessionDeleteResponse!
  deleteOneUser(input: DeleteOneUserInput!): UserDeleteResponse!
  updateManyComments(input: UpdateManyCommentsInput!): UpdateManyResponse!
  updateManyComplaints(input: UpdateManyComplaintsInput!): UpdateManyResponse!
  updateManyLikes(input: UpdateManyLikesInput!): UpdateManyResponse!
  updateManyPosts(input: UpdateManyPostsInput!): UpdateManyResponse!
  updateManySessions(input: UpdateManySessionsInput!): UpdateManyResponse!
  updateManyUsers(input: UpdateManyUsersInput!): UpdateManyResponse!
  updateOneComments(input: UpdateOneCommentsInput!): Comments!
  updateOneComplaint(input: UpdateOneComplaintInput!): Complaint!
  updateOneLike(input: UpdateOneLikeInput!): Like!
  updateOnePost(input: UpdateOnePostInput!): Post!
  updateOneSession(input: UpdateOneSessionInput!): Session!
  updateOneUser(input: UpdateOneUserInput!): User!
}

type OffsetPageInfo {
  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean
}

input OffsetPaging {
  """Limit the number of records returned"""
  limit: Int

  """Offset to start returning records from"""
  offset: Int
}

type PageInfo {
  """The cursor of the last returned record."""
  endCursor: ConnectionCursor

  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor
}

type Post {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type PostAggregateGroupBy {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type PostConnection {
  """Array of nodes."""
  nodes: [Post!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type PostCountAggregate {
  createdAt: Int
  deletedAt: Int
  id: Int
  updatedAt: Int
}

input PostCreatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

input PostDeleteFilter {
  and: [PostDeleteFilter!]
  createdAt: PostCreatedAtFilterComparison
  deletedAt: PostDeletedAtFilterComparison
  id: PostIdFilterComparison
  or: [PostDeleteFilter!]
  updatedAt: PostUpdatedAtFilterComparison
}

type PostDeleteResponse {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input PostDeletedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

input PostFilter {
  and: [PostFilter!]
  createdAt: PostCreatedAtFilterComparison
  deletedAt: PostDeletedAtFilterComparison
  id: PostIdFilterComparison
  or: [PostFilter!]
  updatedAt: PostUpdatedAtFilterComparison
}

input PostIdFilterComparison {
  eq: String
  in: [String!]
  neq: String
  notIn: [String!]
}

type PostMaxAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type PostMinAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input PostSort {
  direction: SortDirection!
  field: PostSortFields!
  nulls: SortNulls
}

enum PostSortFields {
  createdAt
  deletedAt
  id
  updatedAt
}

input PostUpdateFilter {
  and: [PostUpdateFilter!]
  createdAt: PostCreatedAtFilterComparison
  deletedAt: PostDeletedAtFilterComparison
  id: PostIdFilterComparison
  or: [PostUpdateFilter!]
  updatedAt: PostUpdatedAtFilterComparison
}

input PostUpdatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

type Query {
  comments(
    """Specify to filter the records returned."""
    filter: CommentsFilter = {}

    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to sort results."""
    sorting: [CommentsSort!] = []
  ): CommentsConnection!
  complaint(
    """The id of the record to find."""
    id: ID!
  ): Complaint
  complaints(
    """Specify to filter the records returned."""
    filter: ComplaintFilter = {}

    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to sort results."""
    sorting: [ComplaintSort!] = []
  ): ComplaintConnection!
  like(
    """The id of the record to find."""
    id: ID!
  ): Like
  likes(
    """Specify to filter the records returned."""
    filter: LikeFilter = {}

    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to sort results."""
    sorting: [LikeSort!] = []
  ): LikeConnection!
  post(
    """The id of the record to find."""
    id: ID!
  ): Post
  posts(
    """Specify to filter the records returned."""
    filter: PostFilter = {}

    """Limit or page results."""
    paging: OffsetPaging = {limit: 10}

    """Specify to sort results."""
    sorting: [PostSort!] = []
  ): PostConnection!
  session(
    """The id of the record to find."""
    id: ID!
  ): Session
  sessions(
    """Specify to filter the records returned."""
    filter: SessionFilter = {}

    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to sort results."""
    sorting: [SessionSort!] = []
  ): SessionConnection!
  user(
    """The id of the record to find."""
    id: ID!
  ): User
  users(
    """Specify to filter the records returned."""
    filter: UserFilter = {}

    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to sort results."""
    sorting: [UserSort!] = []
  ): UserConnection!
}

type Session {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type SessionAggregateGroupBy {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type SessionConnection {
  """Array of edges."""
  edges: [SessionEdge!]!

  """Paging information"""
  pageInfo: PageInfo!
}

type SessionCountAggregate {
  createdAt: Int
  deletedAt: Int
  id: Int
  updatedAt: Int
}

input SessionCreatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

input SessionDeleteFilter {
  and: [SessionDeleteFilter!]
  createdAt: SessionCreatedAtFilterComparison
  deletedAt: SessionDeletedAtFilterComparison
  id: SessionIdFilterComparison
  or: [SessionDeleteFilter!]
  updatedAt: SessionUpdatedAtFilterComparison
}

type SessionDeleteResponse {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input SessionDeletedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

type SessionEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the Session"""
  node: Session!
}

input SessionFilter {
  and: [SessionFilter!]
  createdAt: SessionCreatedAtFilterComparison
  deletedAt: SessionDeletedAtFilterComparison
  id: SessionIdFilterComparison
  or: [SessionFilter!]
  updatedAt: SessionUpdatedAtFilterComparison
}

input SessionIdFilterComparison {
  eq: String
  in: [String!]
  neq: String
  notIn: [String!]
}

type SessionMaxAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type SessionMinAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input SessionSort {
  direction: SortDirection!
  field: SessionSortFields!
  nulls: SortNulls
}

enum SessionSortFields {
  createdAt
  deletedAt
  id
  updatedAt
}

input SessionUpdateFilter {
  and: [SessionUpdateFilter!]
  createdAt: SessionCreatedAtFilterComparison
  deletedAt: SessionDeletedAtFilterComparison
  id: SessionIdFilterComparison
  or: [SessionUpdateFilter!]
  updatedAt: SessionUpdatedAtFilterComparison
}

input SessionUpdatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

input UpdateCommentInput {
  commentBody: String
  id: Float!
  postId: Float
  userId: String
}

input UpdateComplaintInput {
  comentId: String
  id: Float!
  type: Float
  userId: String
}

input UpdateLikeInput {
  comentId: String
  id: Float!
  type: Float
  userId: String
}

input UpdateManyCommentsInput {
  """Filter used to find fields to update"""
  filter: CommentsUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateCommentInput!
}

input UpdateManyComplaintsInput {
  """Filter used to find fields to update"""
  filter: ComplaintUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateComplaintInput!
}

input UpdateManyLikesInput {
  """Filter used to find fields to update"""
  filter: LikeUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateLikeInput!
}

input UpdateManyPostsInput {
  """Filter used to find fields to update"""
  filter: PostUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdatePostInput!
}

type UpdateManyResponse {
  """The number of records updated."""
  updatedCount: Int!
}

input UpdateManySessionsInput {
  """Filter used to find fields to update"""
  filter: SessionUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateSessionInput!
}

input UpdateManyUsersInput {
  """Filter used to find fields to update"""
  filter: UserUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateUserInput!
}

input UpdateOneCommentsInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateCommentInput!
}

input UpdateOneComplaintInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateComplaintInput!
}

input UpdateOneLikeInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateLikeInput!
}

input UpdateOnePostInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdatePostInput!
}

input UpdateOneSessionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateSessionInput!
}

input UpdateOneUserInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateUserInput!
}

input UpdatePostInput {
  category: String
  id: String!
  postBody: String
  postDateTime: DateTime
  postImageURL: String
  postStatus: Float
  postTitle: String
  postVisibility: Float
  tags: String
}

input UpdateSessionInput {
  id: String!
  token: String
}

input UpdateUserInput {
  id: String!
  userEmail: String
  userName: String
  userPassword: String
}

type User {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type UserAggregateGroupBy {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type UserConnection {
  """Array of edges."""
  edges: [UserEdge!]!

  """Paging information"""
  pageInfo: PageInfo!
}

type UserCountAggregate {
  createdAt: Int
  deletedAt: Int
  id: Int
  updatedAt: Int
}

input UserCreatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

input UserDeleteFilter {
  and: [UserDeleteFilter!]
  createdAt: UserCreatedAtFilterComparison
  deletedAt: UserDeletedAtFilterComparison
  id: UserIdFilterComparison
  or: [UserDeleteFilter!]
  updatedAt: UserUpdatedAtFilterComparison
}

type UserDeleteResponse {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input UserDeletedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}

type UserEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the User"""
  node: User!
}

input UserFilter {
  and: [UserFilter!]
  createdAt: UserCreatedAtFilterComparison
  deletedAt: UserDeletedAtFilterComparison
  id: UserIdFilterComparison
  or: [UserFilter!]
  updatedAt: UserUpdatedAtFilterComparison
}

input UserIdFilterComparison {
  eq: String
  in: [String!]
  neq: String
  notIn: [String!]
}

type UserMaxAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

type UserMinAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  updatedAt: DateTime
}

input UserSort {
  direction: SortDirection!
  field: UserSortFields!
  nulls: SortNulls
}

enum UserSortFields {
  createdAt
  deletedAt
  id
  updatedAt
}

input UserUpdateFilter {
  and: [UserUpdateFilter!]
  createdAt: UserCreatedAtFilterComparison
  deletedAt: UserDeletedAtFilterComparison
  id: UserIdFilterComparison
  or: [UserUpdateFilter!]
  updatedAt: UserUpdatedAtFilterComparison
}

input UserUpdatedAtFilterComparison {
  eq: DateTime
  in: [DateTime!]
  neq: DateTime
  notIn: [DateTime!]
}